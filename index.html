<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TV Facile – Lecteur M3U (HLS + DASH)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Preload HLS (with fallback loader in JS if this CDN fails) -->
  <script src="https://cdn.jsdelivr.net/npm/hls.js@1.4.12/dist/hls.min.js"></script>
  <!-- NOTE: dashjs may be blocked/not reachable in some sandboxes. We'll lazy-load it at runtime if needed. -->
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif; background:#121212; color:#e5e5e5; }
    #video-player-container.hidden { display:none; }
    .grid-container { display:grid; gap:1.25rem; padding:1.25rem; grid-template-columns: repeat(auto-fill, minmax(200px,1fr)); }
    .channel-card { background:#1f1f1f; border:2px solid transparent; border-radius:1rem; cursor:pointer; text-align:center; padding:1rem; display:flex; flex-direction:column; align-items:center; justify-content:center; transition:transform .15s, border-color .15s; }
    .channel-card:hover, .channel-card:focus { transform:scale(1.03); border-color:#22c55e; }
    .channel-card img { max-width:100px; max-height:100px; border-radius:.5rem; object-fit:contain; }
    .channel-card span { margin-top:.75rem; font-size:1.05rem; font-weight:600; }
    .channel-card .program-info { font-size:0.8rem; margin-top: 0.5rem; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; max-width: 100%; color: #a1a1aa; }
    #video-player-container { position:fixed; inset:0; background:#000; z-index:50; display:flex; justify-content:center; align-items:center; }
    #video-player { width:100%; height:100%; }
    #loading-message, #error-message { position:absolute; left:50%; transform:translateX(-50%); color:white; z-index:60; display:none; text-align:center; }
    #loading-message { top:15%; font-size:1.25rem; }
    #error-message { bottom:10%; background:rgba(0,0,0,.75); padding:.75rem 1rem; border-radius:.5rem; max-width:min(90%,720px); }
    .badge { font-size:.75rem; padding:.125rem .5rem; border-radius:.5rem; background:#27272a; border:1px solid #3f3f46; }
    .status-ok { color:#22c55e; }
    .status-bad { color:#ef4444; }
    .channel-card.selected {
      border-color: #22c55e;
      box-shadow: 0 0 0 4px #22c55e, 0 4px 24px #22c55e44;
      background: #232a1e;
      transform: scale(1.08);
      transition: background 0.15s, box-shadow 0.15s, transform 0.15s;
    }
    .filter-btn.selected {
      background-color: #22c55e;
      color: #121212;
      font-weight: bold;
    }
    .main-header {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      margin-top: 1.5rem;
      margin-bottom: 1rem;
      padding: 0 1.5rem;
    }
    .main-header .title {
      font-size: 2.25rem;
      font-weight: 700;
    }
    .main-header .subtitle {
      font-size: 0.875rem;
      color: #9ca3af;
    }
    .header-info {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 1rem;
    }
    .filter-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      padding: 0 1.5rem;
      margin-top: 1rem;
    }
  </style>
</head>
<body>
  <div class="main-header">
    <h1 class="title">TV Facile</h1>
    <p class="subtitle">Cliquez sur une chaîne pour la regarder. Appuyez sur une touche ou <kbd class="badge">Flèche Droite</kbd> pour revenir à la liste.</p>
    <div class="header-info">
      <div id="hls-status" class="badge">HLS: …</div>
      <div id="dash-status" class="badge">DASH: …</div>
      <button id="btn-selftest" class="px-3 py-1 rounded-lg bg-emerald-600 hover:bg-emerald-500 font-semibold text-sm">Auto-test</button>
    </div>
  </div>

  <div class="filter-bar" id="filter-bar">
    <!-- Les boutons de filtre seront générés ici par le script JS -->
  </div>
  <div id="channel-list" class="grid-container"></div>
  <div id="video-player-container" class="hidden">
    <video id="video-player" controls autoplay playsinline muted></video>
    <div id="loading-message">Chargement…</div>
    <div id="error-message">Impossible de charger cette chaîne.</div>
    <iframe id="iframe-player" style="display:none;width:80vw;height:80vh;border:none;border-radius:1rem;z-index:51;"></iframe>
  </div>

  <script>
    // ------------------------------
    // Helpers: dynamic script loader & capability checks
    // ------------------------------
    const HLS_CDNS = [
      'https://cdn.jsdelivr.net/npm/hls.js@1.4.12/dist/hls.min.js',
      'https://unpkg.com/hls.js@1.4.12/dist/hls.min.js',
      'https://cdn.jsdelivr.net/npm/hls.js@latest'
    ];
    const DASH_CDNS = [
      'https://cdn.jsdelivr.net/npm/dashjs@4.7.3/dist/dash.all.min.js',
      'https://unpkg.com/dashjs@4.7.3/dist/dash.all.min.js',
      'https://cdn.dashjs.org/latest/dash.all.min.js'
    ];
    let hls;
    let dashPlayer;

    function loadScriptOnce(url){
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = url; s.async = true; s.defer = true;
        s.onload = () => resolve();
        s.onerror = () => reject(new Error('Failed: ' + url));
        document.head.appendChild(s);
      });
    }

    async function ensureLib(globalName, urls){
      if (window[globalName]) return true;
      for (const u of urls){
        try { await loadScriptOnce(u); if (window[globalName]) return true; } catch(e) { /* try next */ }
      }
      return !!window[globalName];
    }

    function isProbablyHls(url){ return /\.m3u8(\?|$)/i.test(url); }
    function isProbablyDash(url){ return /\.mpd(\?|$)/i.test(url); }

    // ------------------------------
    // Channels and XMLTV logic
    // ------------------------------
    let allChannels = [];
    let programData = {};
    let xmlChannelData = {};

    async function fetchAndParseXmltv(url = 'xmltv.xml'){
      try {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error('Le fichier xmltv.xml n\'a pas été trouvé ou chargé.');
        }
        const xmlText = await response.text();
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
        
        xmlChannelData = parseXmlChannelData(xmlDoc);

        const programs = Array.from(xmlDoc.querySelectorAll('programme')).map(p => {
          const channelId = p.getAttribute('channel');
          const start = new Date(p.getAttribute('start').replace(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2}).*/, '$1-$2-$3T$4:$5:$6'));
          const stop = new Date(p.getAttribute('stop').replace(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2}).*/, '$1-$2-$3T$4:$5:$6'));
          const title = p.querySelector('title')?.textContent || 'Programme inconnu';
          const subtitle = p.querySelector('sub-title')?.textContent || '';
          return { channelId, start, stop, title, subtitle };
        });

        programData = {};
        programs.forEach(p => {
          if (!programData[p.channelId]) programData[p.channelId] = [];
          programData[p.channelId].push(p);
        });
        
        console.log('Fichier XMLTV chargé et analysé avec succès.');
        updateCurrentPrograms();

      } catch (e) {
        console.error('Erreur lors du chargement ou de l\'analyse du fichier XMLTV:', e);
        programData = {};
        xmlChannelData = {};
      }
    }
    
    function parseXmlChannelData(xmlDoc) {
      const channels = {};
      Array.from(xmlDoc.querySelectorAll('channel')).forEach(c => {
        const id = c.getAttribute('id');
        const name = c.querySelector('display-name')?.textContent || 'Nom inconnu';
        const icon = c.querySelector('icon')?.getAttribute('src') || '';
        if (id) {
            channels[id] = { name, icon };
        }
      });
      return channels;
    }
    
    const defaultM3u = `#EXTM3U
#EXTINF:-1 tvg-id="France2.fr" tvg-name="France 2" tvg-logo="https://spideyaxel.github.io/tv/logo/02.png" group-title="general",France 2
https://raw.githubusercontent.com/spideyaxel/tv/main/france2.m3u8

#EXTINF:-1 tvg-id="France3.fr" tvg-name="France 3" tvg-logo="https://spideyaxel.github.io/tv/logo/03.png" group-title="general",France 3
https://raw.githubusercontent.com/spideyaxel/tv/main/france3.m3u8

#EXTINF:-1 tvg-id="France5.fr" tvg-name="France 5" tvg-logo="https://spideyaxel.github.io/tv/logo/05.png" group-title="general",France 5
https://raw.githubusercontent.com/spideyaxel/tv/main/france5.m3u8

#EXTINF:-1 tvg-id="M6.fr" tvg-name="M6" tvg-logo="https://spideyaxel.github.io/tv/logo/06.png" group-title="general",M6
https://raw.githubusercontent.com/spideyaxel/tv/main/m6.m3u8

#EXTINF:-1 tvg-id="Arte.fr" tvg-name="Arte" tvg-logo="https://spideyaxel.github.io/tv/logo/07.png" group-title="general",Arte
https://raw.githubusercontent.com/spideyaxel/tv/main/arte.m3u8

#EXTINF:-1 tvg-id="C8.fr" tvg-name="C8" tvg-logo="https://spideyaxel.github.io/tv/logo/08.png" group-title="general",C8
https://raw.githubusercontent.com/spideyaxel/tv/main/c8.m3u8

#EXTINF:-1 tvg-id="W9.fr" tvg-name="W9" tvg-logo="https://spideyaxel.github.io/tv/logo/09.png" group-title="general",W9
https://raw.githubusercontent.com/spideyaxel/tv/main/w9.m3u8

`;

    function parseM3u(data){
      const channels = [];
      const lines = data.split('\n');
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].startsWith('#EXTINF:')){
          const line = lines[i];
          const url = lines[i+1];
          if (!url) continue;

          const nameMatch = /tvg-name="([^"]+)"/.exec(line) || /,([^,]+)$/.exec(line);
          const groupMatch = /group-title="([^"]*)"/.exec(line);
          const idMatch = /tvg-id="([^"]+)"/.exec(line);

          const name = nameMatch ? nameMatch[1].trim() : 'Nom inconnu';
          const group = groupMatch ? groupMatch[1].trim() : 'divers';
          const id = idMatch ? idMatch[1].trim() : name;

          // Utilise les données du fichier XMLTV si elles existent
          const xmlChannel = xmlChannelData[id];
          const logo = xmlChannel ? xmlChannel.icon : (/tvg-logo="([^"]+)"/.exec(line) ? /tvg-logo="([^"]+)"/.exec(line)[1].trim() : '');
          const displayName = xmlChannel ? xmlChannel.name : name;

          channels.push({name: displayName, logo, group, url, id});
          i++;
        }
      }
      return channels;
    }

    async function loadPlaylists() {
      await fetchAndParseXmltv();
      allChannels = parseM3u(defaultM3u);
      
      const groups = [...new Set(allChannels.map(c => c.group))];
      createFilterButtons(groups);
      renderChannels(allChannels);

      // Met à jour les programmes toutes les 30 secondes
      setInterval(updateCurrentPrograms, 30000);
    }
    
    function updateCurrentPrograms(){
      const now = new Date();
      const channelCards = document.querySelectorAll('.channel-card');
      channelCards.forEach(card => {
        const channelId = card.dataset.id;
        const currentProgram = (programData[channelId] || []).find(p => now >= p.start && now <= p.stop);
        const programInfoSpan = card.querySelector('.program-info');
        if(programInfoSpan){
          programInfoSpan.textContent = currentProgram ? `${currentProgram.title} - ${currentProgram.subtitle || ''}`.trim() : 'Programme non disponible';
        }
      });
    }

    function createFilterButtons(groups) {
      const filterBar = document.getElementById('filter-bar');
      filterBar.innerHTML = '';
      const allBtn = document.createElement('button');
      allBtn.className = 'badge filter-btn selected';
      allBtn.dataset.filter = 'all';
      allBtn.textContent = 'Tout';
      filterBar.appendChild(allBtn);

      groups.forEach(group => {
        const btn = document.createElement('button');
        btn.className = 'badge filter-btn';
        btn.dataset.filter = group;
        btn.textContent = group.charAt(0).toUpperCase() + group.slice(1);
        filterBar.appendChild(btn);
      });
      updateFilterSelection();
    }

    function updateFilterSelection() {
      const filterBtns = Array.from(document.querySelectorAll('#filter-bar .filter-btn'));
      filterBtns.forEach((btn, i) => {
        btn.classList.toggle('selected', i === filterIndex);
        btn.tabIndex = 0;
        btn.focus();
      });
      if (filterBtns[filterIndex]) filterBtns[filterIndex].focus();
    }

    function updateSelection() {
      const cards = Array.from(document.querySelectorAll('.channel-card'));
      cards.forEach((card, i) => {
        card.classList.toggle('selected', i === selectedIndex);
        card.tabIndex = 0;
      });
      if (cards[selectedIndex]) cards[selectedIndex].focus();
    }

    function renderChannels(channels){
      const channelList = document.getElementById('channel-list');
      channelList.innerHTML = '';
      channels.forEach(c => {
        const card = document.createElement('div');
        card.className = 'channel-card';
        card.dataset.url = c.url;
        card.dataset.name = c.name;
        card.dataset.group = c.group;
        card.dataset.id = c.id;
        const img = document.createElement('img');
        img.src = c.logo || 'https://placehold.co/100x100?text=TV';
        img.alt = c.name;
        const name = document.createElement('span');
        name.textContent = c.name;
        const programInfo = document.createElement('span');
        programInfo.className = 'program-info';
        programInfo.textContent = 'Chargement...';
        card.append(img, name, programInfo);
        channelList.appendChild(card);
      });
      selectedIndex = 0;
      updateSelection();
      updateCurrentPrograms();
    }

    function filterChannels(filter) {
      if (filter === "all") return allChannels;
      return allChannels.filter(c => c.group.toLowerCase() === filter.toLowerCase());
    }

    // ------------------------------
    // Playback logic (robust + lazy load libs)
    // ------------------------------
    function resetPlayers(){
      const video = document.getElementById('video-player');
      try { if (hls){ hls.destroy(); hls = null; } } catch {}
      try { if (dashPlayer){ dashPlayer.reset(); dashPlayer = null; } } catch {}
      try { video.pause(); video.removeAttribute('src'); video.load(); } catch {}
      const iframe = document.getElementById('iframe-player');
      if (iframe) { iframe.src = ''; iframe.style.display = 'none'; }
      video.style.display = '';
    }

    async function playChannel(url){
      const videoPlayerContainer = document.getElementById('video-player-container');
      const loadingMessage = document.getElementById('loading-message');
      const errorMessage = document.getElementById('error-message');
      const video = document.getElementById('video-player');

      loadingMessage.style.display = 'block';
      errorMessage.style.display = 'none';
      videoPlayerContainer.classList.remove('hidden');
      resetPlayers();

      try {
        video.muted = true;
        const canNative = video.canPlayType('application/vnd.apple.mpegURL');
        if (isProbablyHls(url) && canNative){
          video.src = url;
          await video.play();
          video.muted = false;
          return;
        }

        if (isProbablyHls(url)){
          const ok = await ensureLib('Hls', HLS_CDNS);
          if (!ok){ throw new Error('HLS library introuvable (CDN bloqué)'); }
          hls = new window.Hls();
          hls.on(window.Hls.Events.ERROR, (ev, data) => {
            if (data.fatal){
              if (data.type === 'networkError') {
                showError('Erreur HLS fatale: networkError (CORS ou géo-blocage probable)');
              } else {
                showError('Erreur HLS fatale: ' + data.type);
              }
              resetPlayers();
            }
          });
          hls.loadSource(url);
          hls.attachMedia(video);
          hls.on(window.Hls.Events.MANIFEST_PARSED, async () => {
            try {
              await video.play();
              video.muted = false;
            } catch(e){}
          });
          return;
        }

        if (isProbablyDash(url)){
          const ok = await ensureLib('dashjs', DASH_CDNS);
          if (!ok){ throw new Error('DASH (dashjs) introuvable dans cet environnement'); }
          dashPlayer = window.dashjs.MediaPlayer().create();
          dashPlayer.initialize(video, url, true);
          setTimeout(() => { video.muted = false; }, 500);
          return;
        }

        video.src = url;
        await video.play();
        video.muted = false;
      } catch (err){
        showError(
          (err && err.message ? err.message : 'Erreur de lecture') +
          '\nSi le flux ne fonctionne pas, il est probablement bloqué par le serveur (CORS, géo-blocage, DRM).'
        );
        resetPlayers();
        videoPlayerContainer.classList.add('hidden');
      } finally {
        loadingMessage.style.display = 'none';
      }
    }

    function showError(msg){
      const errorMessage = document.getElementById('error-message');
      errorMessage.textContent = msg || 'Impossible de charger cette chaîne.';
      errorMessage.style.display = 'block';
    }

    function stopPlayback(){
      const videoPlayerContainer = document.getElementById('video-player-container');
      const errorMessage = document.getElementById('error-message');
      const loadingMessage = document.getElementById('loading-message');
      const video = document.getElementById('video-player');
      resetPlayers();
      videoPlayerContainer.classList.add('hidden');
      errorMessage.style.display = 'none';
      loadingMessage.style.display = 'none';
      video.style.display = '';
      document.getElementById('iframe-player').style.display = 'none';
    }

    // ------------------------------
    // Self-diagnostics ("tests")
    // ------------------------------
    function refreshStatusBadges(){
      const hlsStatus = document.getElementById('hls-status');
      const dashStatus = document.getElementById('dash-status');
      const hlsOk = !!window.Hls;
      hlsStatus.textContent = 'HLS: ' + (hlsOk ? 'chargé' : 'non chargé');
      hlsStatus.classList.toggle('status-ok', hlsOk);
      hlsStatus.classList.toggle('status-bad', !hlsOk);

      const dashOk = !!window.dashjs;
      dashStatus.textContent = 'DASH: ' + (dashOk ? 'chargé' : 'non chargé');
      dashStatus.classList.toggle('status-ok', dashOk);
      dashStatus.classList.toggle('status-bad', !dashOk);
    }

    async function runSelfTest(){
      const btnSelfTest = document.getElementById('btn-selftest');
      btnSelfTest.disabled = true;
      // Try to ensure both libs
      await ensureLib('Hls', HLS_CDNS);
      await ensureLib('dashjs', DASH_CDNS);
      refreshStatusBadges();
      btnSelfTest.disabled = false;
    }

    // ------------------------------
    // Events
    // ------------------------------
    let selectedIndex = 0;
    let filterIndex = 0;
    let filterActive = false;
    let currentFilter = 'all';

    document.addEventListener('DOMContentLoaded', () => {
      const channelList = document.getElementById('channel-list');
      const filterBar = document.getElementById('filter-bar');
      const videoPlayerContainer = document.getElementById('video-player-container');
      const video = document.getElementById('video-player');
      const loadingMessage = document.getElementById('loading-message');
      const errorMessage = document.getElementById('error-message');
      const btnSelfTest = document.getElementById('btn-selftest');
      
      loadPlaylists();
      refreshStatusBadges();
      
      filterBar.addEventListener('click', (e) => {
        const btn = e.target.closest('.filter-btn');
        if (!btn) return;
        currentFilter = btn.dataset.filter;
        Array.from(document.querySelectorAll('#filter-bar .filter-btn')).forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
        renderChannels(filterChannels(currentFilter));
        selectedIndex = 0;
        filterActive = false;
        setTimeout(updateSelection, 100);
      });

      channelList.addEventListener('click', (e) => {
        const cards = Array.from(document.querySelectorAll('.channel-card'));
        const card = e.target.closest('.channel-card');
        if (!card) return;
        selectedIndex = cards.indexOf(card);
        updateSelection();
        playChannel(card.dataset.url);
      });

      document.addEventListener('keydown', (e) => {
        const cards = Array.from(document.querySelectorAll('.channel-card'));
        const grid = document.querySelector('.grid-container');
        const style = window.getComputedStyle(grid);
        const columns = parseInt(style.getPropertyValue('grid-template-columns').split(' ').length);
        const filterBtns = Array.from(document.querySelectorAll('#filter-bar .filter-btn'));

        if (e.key === 'Tab' || e.key === 't') {
          filterActive = !filterActive;
          if (filterActive) {
            updateFilterSelection();
          } else {
            selectedIndex = 0;
            updateSelection();
          }
          e.preventDefault();
          return;
        }

        if (filterActive) {
          if (e.key === 'ArrowRight') {
            filterIndex = (filterIndex + 1) % filterBtns.length;
            updateFilterSelection();
            e.preventDefault();
          }
          if (e.key === 'ArrowLeft') {
            filterIndex = (filterIndex - 1 + filterBtns.length) % filterBtns.length;
            updateFilterSelection();
            e.preventDefault();
          }
          if (e.key === 'ArrowDown') {
            filterActive = false;
            selectedIndex = 0;
            updateSelection();
            e.preventDefault();
            return;
          }
          if (e.key === 'Enter') {
            const btn = filterBtns[filterIndex];
            if (btn) {
              currentFilter = btn.dataset.filter;
              Array.from(filterBtns).forEach(b => b.classList.remove('selected'));
              btn.classList.add('selected');
              renderChannels(filterChannels(currentFilter));
              selectedIndex = 0;
              filterActive = false;
              setTimeout(updateSelection, 100);
              e.preventDefault();
            }
          }
          return;
        }

        if (!videoPlayerContainer.classList.contains('hidden')) {
          if (
            e.key === 'ArrowDown' ||
            e.key === 'ArrowUp' ||
            e.key === 'ArrowLeft' ||
            e.key === 'ArrowRight' ||
            e.key === 'Escape' ||
            e.key === 'Backspace'
          ) {
            stopPlayback();
            updateSelection();
            e.preventDefault();
          }
          return;
        }
        
        if (videoPlayerContainer.classList.contains('hidden')) {
          if (e.key === 'ArrowDown') {
            selectedIndex = Math.min(selectedIndex + columns, cards.length - 1);
            updateSelection();
            e.preventDefault();
          }
          if (e.key === 'ArrowUp') {
            if (selectedIndex < columns) {
              filterActive = true;
              filterIndex = 0;
              updateFilterSelection();
              e.preventDefault();
            } else {
              selectedIndex = Math.max(selectedIndex - columns, 0);
              updateSelection();
              e.preventDefault();
            }
          }
          if (e.key === 'ArrowRight') {
            selectedIndex = (selectedIndex + 1) % cards.length;
            updateSelection();
            e.preventDefault();
          }
          if (e.key === 'ArrowLeft') {
            selectedIndex = (selectedIndex - 1 + cards.length) % cards.length;
            updateSelection();
            e.preventDefault();
          }
          if (e.key === 'Enter') {
            if (cards[selectedIndex]) {
              playChannel(cards[selectedIndex].dataset.url);
              e.preventDefault();
            }
          }
        } else {
          if (e.key === 'Escape' || e.key === 'Backspace') {
            stopPlayback();
            updateSelection();
          }
        }
      });

      video.addEventListener('playing', () => { loadingMessage.style.display = 'none'; });
      video.addEventListener('error', () => { showError('Erreur vidéo'); });

      btnSelfTest.addEventListener('click', () => runSelfTest());
    });
  </script>
</body>
</html>


